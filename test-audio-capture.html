<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Audio Capture Test</title>
    <style>
        body { font-family: monospace; padding: 20px; }
        button { padding: 10px 20px; margin: 10px 0; }
        .log { background: #f0f0f0; padding: 10px; margin: 10px 0; border-radius: 5px; }
        .error { color: red; }
        .success { color: green; }
    </style>
</head>
<body>
    <h1>üîç Audio Capture Diagnostics</h1>

    <button id="testBtn">üé§ Test 5s Recording</button>
    <button id="playBtn" disabled>‚ñ∂Ô∏è Play Recording</button>

    <div id="logs"></div>

    <script>
        const testBtn = document.getElementById('testBtn');
        const playBtn = document.getElementById('playBtn');
        const logsEl = document.getElementById('logs');
        let audioBlob = null;
        let mediaRecorder, audioChunks = [];

        function log(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `log ${type}`;
            div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logsEl.appendChild(div);
            console.log(message);
        }

        function getSupportedMimeType() {
            const types = [
                'audio/webm;codecs=opus',
                'audio/mp4',
                'audio/webm',
                'audio/ogg;codecs=opus'
            ];

            for (const type of types) {
                if (MediaRecorder.isTypeSupported(type)) {
                    log(`‚úÖ Detected MIME type: ${type}`, 'success');
                    return type;
                }
            }

            log('‚ö†Ô∏è No optimal format found, using default', 'error');
            return '';
        }

        testBtn.onclick = async () => {
            logsEl.innerHTML = '';
            log('Starting audio capture test...');

            try {
                // Test getUserMedia with detailed config
                log('Requesting microphone access...');
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 44100,
                        channelCount: 1
                    }
                });

                log(`‚úÖ Microphone access granted`, 'success');
                log(`Audio tracks: ${stream.getAudioTracks().length}`);

                const track = stream.getAudioTracks()[0];
                const settings = track.getSettings();
                log(`Track settings: ${JSON.stringify(settings)}`);

                // Initialize MediaRecorder
                const mimeType = getSupportedMimeType();
                const options = mimeType ? { mimeType } : {};

                mediaRecorder = new MediaRecorder(stream, options);
                audioChunks = [];

                log(`üìù MediaRecorder created`);
                log(`   MIME type: ${mediaRecorder.mimeType}`);
                log(`   State: ${mediaRecorder.state}`);
                log(`   Video bits/s: ${mediaRecorder.videoBitsPerSecond || 'N/A'}`);
                log(`   Audio bits/s: ${mediaRecorder.audioBitsPerSecond || 'N/A'}`);

                mediaRecorder.ondataavailable = (e) => {
                    log(`üì¶ Data available: ${(e.data.size / 1024).toFixed(2)} KB`);
                    if (e.data.size > 0) {
                        audioChunks.push(e.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    stream.getTracks().forEach(t => t.stop());

                    audioBlob = new Blob(audioChunks, {
                        type: mediaRecorder.mimeType || 'audio/webm'
                    });

                    log(`‚úÖ Recording stopped`, 'success');
                    log(`   Total chunks: ${audioChunks.length}`);
                    log(`   Blob size: ${(audioBlob.size / 1024).toFixed(2)} KB`);
                    log(`   Blob type: ${audioBlob.type}`);

                    if (audioBlob.size < 10 * 1024) {
                        log(`‚ö†Ô∏è WARNING: Audio file is very small (< 10KB)`, 'error');
                        log(`   This suggests audio was not captured properly`, 'error');
                    } else {
                        log(`‚úÖ Audio size looks good`, 'success');
                    }

                    playBtn.disabled = false;
                };

                mediaRecorder.onerror = (e) => {
                    log(`‚ùå MediaRecorder error: ${e.error}`, 'error');
                };

                // Start recording
                testBtn.disabled = true;
                testBtn.textContent = 'üî¥ Recording (5s)...';

                mediaRecorder.start();
                log('üé§ Recording started...');

                // Stop after 5 seconds
                setTimeout(() => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                        testBtn.disabled = false;
                        testBtn.textContent = 'üé§ Test 5s Recording';
                    }
                }, 5000);

            } catch (error) {
                log(`‚ùå Error: ${error.message}`, 'error');
                log(`   ${error.stack}`, 'error');
            }
        };

        playBtn.onclick = () => {
            if (audioBlob) {
                log('‚ñ∂Ô∏è Playing recording...');
                const audio = new Audio(URL.createObjectURL(audioBlob));
                audio.play();
                audio.onended = () => log('‚úÖ Playback finished', 'success');
                audio.onerror = (e) => log(`‚ùå Playback error: ${e}`, 'error');
            }
        };
    </script>
</body>
</html>
